---
source: crates/ruff_linter/src/rules/mccabe/mod.rs
---
error[C901]: 2:5: `trivial` is too complex (1 > 0)

 --> C901.py:2:5
  |
1 | # Complexity = 1
2 | def trivial():
  |     ^^^^^^^
3 |     pass
  |
error[C901]: 7:5: `expr_as_statement` is too complex (1 > 0)

 --> C901.py:7:5
  |
6 | # Complexity = 1
7 | def expr_as_statement():
  |     ^^^^^^^^^^^^^^^^^
8 |     0xF00D
  |
error[C901]: 12:5: `sequential` is too complex (1 > 0)

  --> C901.py:12:5
   |
11 | # Complexity = 1
12 | def sequential(n):
   |     ^^^^^^^^^^
13 |     k = n + 4
14 |     s = k + n
   |
error[C901]: 19:5: `if_elif_else_dead_path` is too complex (3 > 0)

  --> C901.py:19:5
   |
18 | # Complexity = 3
19 | def if_elif_else_dead_path(n):
   |     ^^^^^^^^^^^^^^^^^^^^^^
20 |     if n > 3:
21 |         return "bigger than three"
   |
error[C901]: 29:5: `nested_ifs` is too complex (3 > 0)

  --> C901.py:29:5
   |
28 | # Complexity = 3
29 | def nested_ifs():
   |     ^^^^^^^^^^
30 |     if n > 3:
31 |         if n > 4:
   |
error[C901]: 40:5: `for_loop` is too complex (2 > 0)

  --> C901.py:40:5
   |
39 | # Complexity = 2
40 | def for_loop():
   |     ^^^^^^^^
41 |     for i in range(10):
42 |         print(i)
   |
error[C901]: 46:5: `for_else` is too complex (2 > 0)

  --> C901.py:46:5
   |
45 | # Complexity = 2
46 | def for_else(mylist):
   |     ^^^^^^^^
47 |     for i in mylist:
48 |         print(i)
   |
error[C901]: 54:5: `recursive` is too complex (2 > 0)

  --> C901.py:54:5
   |
53 | # Complexity = 2
54 | def recursive(n):
   |     ^^^^^^^^^
55 |     if n > 4:
56 |         return f(n - 1)
   |
error[C901]: 62:5: `nested_functions` is too complex (3 > 0)

  --> C901.py:62:5
   |
61 | # Complexity = 3
62 | def nested_functions():
   |     ^^^^^^^^^^^^^^^^
63 |     def a():
64 |         def b():
   |
error[C901]: 63:9: `a` is too complex (2 > 0)

  --> C901.py:63:9
   |
61 | # Complexity = 3
62 | def nested_functions():
63 |     def a():
   |         ^
64 |         def b():
65 |             pass
   |
error[C901]: 64:13: `b` is too complex (1 > 0)

  --> C901.py:64:13
   |
62 | def nested_functions():
63 |     def a():
64 |         def b():
   |             ^
65 |             pass
   |
error[C901]: 73:5: `try_else` is too complex (4 > 0)

  --> C901.py:73:5
   |
72 | # Complexity = 4
73 | def try_else():
   |     ^^^^^^^^
74 |     try:
75 |         print(1)
   |
error[C901]: 85:5: `nested_try_finally` is too complex (1 > 0)

  --> C901.py:85:5
   |
84 | # Complexity = 3
85 | def nested_try_finally():
   |     ^^^^^^^^^^^^^^^^^^
86 |     try:
87 |         try:
   |
error[C901]: 96:11: `foobar` is too complex (3 > 0)

  --> C901.py:96:11
   |
95 | # Complexity = 3
96 | async def foobar(a, b, c):
   |           ^^^^^^
97 |     await whatever(a, b, c)
98 |     if await b:
   |
error[C901]: 107:5: `annotated_assign` is too complex (1 > 0)

   --> C901.py:107:5
    |
106 | # Complexity = 1
107 | def annotated_assign():
    |     ^^^^^^^^^^^^^^^^
108 |     x: Any = None
    |
error[C901]: 113:9: `handle` is too complex (9 > 0)

   --> C901.py:113:9
    |
111 | # Complexity = 9
112 | class Class:
113 |     def handle(self, *args, **options):
    |         ^^^^^^
114 |         if args:
115 |             return
    |
error[C901]: 118:17: `a` is too complex (1 > 0)

   --> C901.py:118:17
    |
117 |         class ServiceProvider:
118 |             def a(self):
    |                 ^
119 |                 pass
    |
error[C901]: 121:17: `b` is too complex (2 > 0)

   --> C901.py:121:17
    |
119 |                 pass
120 | 
121 |             def b(self, data):
    |                 ^
122 |                 if not args:
123 |                     pass
    |
error[C901]: 126:17: `c` is too complex (1 > 0)

   --> C901.py:126:17
    |
125 |         class Logger:
126 |             def c(*args, **kwargs):
    |                 ^
127 |                 pass
    |
error[C901]: 129:17: `error` is too complex (1 > 0)

   --> C901.py:129:17
    |
127 |                 pass
128 | 
129 |             def error(self, message):
    |                 ^^^^^
130 |                 pass
    |
error[C901]: 132:17: `info` is too complex (1 > 0)

   --> C901.py:132:17
    |
130 |                 pass
131 | 
132 |             def info(self, message):
    |                 ^^^^
133 |                 pass
    |
error[C901]: 135:17: `exception` is too complex (1 > 0)

   --> C901.py:135:17
    |
133 |                 pass
134 | 
135 |             def exception(self):
    |                 ^^^^^^^^^
136 |                 pass
    |
